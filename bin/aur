#!/usr/bin/env ruby
# frozen_string_literal: true

require 'docopt'
require 'pathname'
require_relative '../lib/aur/action'

CMDS = %i[artfix
          flac2mp3
          help
          info
          inumber
          lint
          lintdir
          ls
          name2num
          name2tag
          num2name
          reencode
          renumber
          retitle
          set
          sort
          split
          strip
          tag2name
          tagsub
          thes
          transcode
          check
          verify].freeze

docopt = <<~EOCMDS
  Usage:
    aur set [-q] <tag> <value> <file>...
    aur tag2name <file>...
    aur name2tag <file>...
    aur num2name <file>...
    aur name2num <file>...
    aur retitle [-n] <file>...
    aur tagsub <tag> <find> <replace> <file>...
    aur inumber <file>...
    aur strip <file>...
    aur renumber (up|down) <number> <file>...
    aur split <file>...
    aur info <file>...
    aur ls [-r] [-d string] [<directory>]...
    aur sort <file>...
    aur check <file>...
    aur verify <file>...
    aur flac2mp3 [-rF] <file>...
    aur transcode <newtype> <file>...
    aur reencode <file>...
    aur lint [-st] <file>...
    aur lintdir [-r] <directory>...
    aur artfix [-n] <directory>...
    aur thes <file>...
    aur help <command>

  Options:
    -n, --noop        don't perform the requested operation
    -q, --quiet       don't print non-warning/error messages
    -r, --recursive   operate recursively
    -s, --summary     summarise results
    -d, --delimiter   produce machine-parseable output with the given delimeter
    -t, --strict      compare actual to expected tags
    -F, --force       overwrite any existing files
EOCMDS

def sanitize_keys(options)
  options.transform_keys { |k| k.to_s.delete('-').to_sym }
end

def errors(errs)
  return if errs.empty?

  errs = errs.sort.uniq

  warn "Completed with #{errs.size} errors."
  errs.each { |err| warn "  #{err}" }
  exit 1
end

begin
  tw = IO.console.winsize.last
  raise StandardError if tw < 60
rescue StandardError
  tw = 80
ensure
  TW = tw
end

begin
  opts = sanitize_keys(Docopt.docopt(docopt))
rescue Docopt::Exit => e
  abort e.message
end

CMDS.each do |cmd|
  next unless opts[cmd]

  cmd = Aur::Action.new(cmd, opts[:'<file>'], opts)
  cmd.run!
  errors(cmd.errs) unless cmd&.no_error_report
  exit
end

abort 'Unhandled command.'
