#!/usr/bin/env ruby
# frozen_string_literal: true

require 'docopt'
require 'pathname'
require_relative '../lib/aur/action'

CMDS = %i[artfix
          flac2mp3
          help
          info
          inumber
          lint
          lintdir
          name2num
          name2tag
          num2name
          reencode
          renumber
          set
          sort
          split
          strip
          tag2name
          thes
          transcode
          verify].freeze

docopt = <<~EOCMDS
  Usage:
    aur set [-q] <tag> <value> <file>...
    aur tag2name <file>...
    aur name2tag <file>...
    aur num2name <file>...
    aur name2num <file>...
    aur inumber <file>...
    aur strip <file>...
    aur renumber (up|down) <number> <file>...
    aur split <file>...
    aur info <file>...
    aur sort <file>...
    aur verify <file>...
    aur flac2mp3 <file>...
    aur transcode <newtype> <file>...
    aur reencode <file>...
    aur lint [-s] <file>...
    aur lintdir [-r] <directory>...
    aur artfix [-n] <directory>...
    aur thes <file>...
    aur help <command>

  Options:
    -n, --noop        don't perform the requested operation
    -q, --quiet       don't print non-warning/error messages
    -r, --recursive   lint directories recursively
    -s, --summary     summarise results
EOCMDS

def sanitize_keys(options)
  options.transform_keys { |k| k.to_s.delete('-').to_sym }
end

def errors(errs)
  return if errs.empty?

  errs = errs.sort.uniq

  warn "Completed with #{errs.size} errors."
  errs.each { |err| warn "  #{err}" }
  exit 1
end

begin
  opts = sanitize_keys(Docopt.docopt(docopt))
rescue Docopt::Exit => e
  abort e.message
end

CMDS.each do |cmd|
  next unless opts[cmd]

  cmd = Aur::Action.new(cmd, opts[:'<file>'], opts)
  cmd.run!
  errors(cmd.errs)
  exit
end

abort 'Unhandled command.'
